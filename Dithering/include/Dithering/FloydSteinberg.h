#pragma once

#include "DitheringBase.h"
#include "util.h"

namespace dithering
{
	/**
	 *  Deprecated : using file assignmented weights instead.
	 */
	class FloydSteinberg : public DitheringBase
	{
	public:
		FloydSteinberg() {};
		~FloydSteinberg() {};

		/**
		 *	@pre
		 *		inputImage needs to be a grayscale image, either generated by converting all colors to gray,
		 *		or by specifing grayscale mode in imread.
		 *	@param inputImage
		 *		the image that will be dithered.
		 */
		virtual cv::Mat dither(cv::Mat inputImage) override
		{
			cv::Mat outputImage = inputImage.clone();

			const int width = outputImage.cols;
			const int height = outputImage.rows;

			//std::cout << "width = " << width << ", height = " << height << std::endl;
			// when using Point as position
			// top left corner is Point(0, 0)
			// top right corner is Point(width-1, 0)

			for (int i = 0; i < height; i++) // 375
			{
				for (int j = 0; j < width; j++) // 600
				{
					// uint8_t ranges from 0 to 255
					uint8_t oldpixel = outputImage.at<uint8_t>(i, j);
					uint8_t newpixel = (oldpixel > 127 ? 255 : 0);

					outputImage.at<uint8_t>(i, j) = newpixel;
					int8_t quant_error = oldpixel - newpixel;

					if (j + 1 < width && j > 0 && i + 1 < height)
					{
						// use bit shifting ( >> 4 ) instead of integer dividing, saving performance
						outputImage.at<uint8_t>(i, j + 1) = saturated_add(outputImage.at<uint8_t>(i, j + 1), (quant_error * 7) >> 4);
						outputImage.at<uint8_t>(i + 1, j + 1) = saturated_add(outputImage.at<uint8_t>(i + 1, j + 1), (quant_error * 3) >> 4);
						outputImage.at<uint8_t>(i + 1, j) = saturated_add(outputImage.at<uint8_t>(i + 1, j), (quant_error * 5) >> 4);
						outputImage.at<uint8_t>(i + 1, j - 1) = saturated_add(outputImage.at<uint8_t>(i + 1, j - 1), (quant_error * 1) >> 4);
					}
				}
			}

			return outputImage;
		}
	};
}